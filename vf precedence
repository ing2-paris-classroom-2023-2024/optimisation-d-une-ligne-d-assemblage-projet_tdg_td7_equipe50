#include <stdio.h>
#include <stdlib.h>

typedef struct Noeud {
    int valeur;
    struct Noeud* suivant;
} Noeud;
    
typedef struct {
    int nombreNoeuds;
    Noeud** listeAdjacence;
} Graphe;

Graphe* initialiserGraphe(int nombreNoeuds) {
    Graphe* graphe = (Graphe*)malloc(sizeof(Graphe));
    graphe->nombreNoeuds = nombreNoeuds;
    graphe->listeAdjacence = (Noeud**)malloc(nombreNoeuds * sizeof(Noeud*));

    for (int i = 0; i < nombreNoeuds; ++i) {
        graphe->listeAdjacence[i] = NULL;
    }

    return graphe;
}

void ajouterArete(Graphe* graphe, int source, int destination) {
    Noeud* nouveauNoeud = (Noeud*)malloc(sizeof(Noeud));
    nouveauNoeud->valeur = destination;
    nouveauNoeud->suivant = graphe->listeAdjacence[source];
    graphe->listeAdjacence[source] = nouveauNoeud;
}

void libererGraphe(Graphe* graphe) {
    for (int i = 0; i < graphe->nombreNoeuds; ++i) {
        Noeud* noeudCourant = graphe->listeAdjacence[i];
        while (noeudCourant != NULL) {
            Noeud* noeudSuivant = noeudCourant->suivant;
            free(noeudCourant);
            noeudCourant = noeudSuivant;
        }
    }

    free(graphe->listeAdjacence);
    free(graphe);
}

int trouverNombreNoeuds(FILE* fichier) {
    int source, destination;
    int maxNoeud = 0;

    while (fscanf(fichier, "%d %d", &source, &destination) == 2) {
        if (source > maxNoeud) {
            maxNoeud = source;
        }
        if (destination > maxNoeud) {
            maxNoeud = destination;
        }
    }

    return maxNoeud + 1;  // Ajouter 1 car les nœuds sont numérotés à partir de 0
}


void triTopologiqueRecursif(Graphe* graphe, int sommet, int* visite, int* rang, int* dernierRang) {
    visite[sommet] = 1;

    Noeud* voisin = graphe->listeAdjacence[sommet];
    while (voisin != NULL) {
        if (!visite[voisin->valeur]) {
            triTopologiqueRecursif(graphe, voisin->valeur, visite, rang, dernierRang);
        }
        voisin = voisin->suivant;
    }

    rang[sommet] = (*dernierRang)--;
}

void triTopologique(Graphe* graphe, int* rang) {
    int* visite = (int*)calloc(graphe->nombreNoeuds, sizeof(int));
    int dernierRang = graphe->nombreNoeuds;

    for (int i = 0; i < graphe->nombreNoeuds; ++i) {
        if (!visite[i]) {
            triTopologiqueRecursif(graphe, i, visite, rang, &dernierRang);
        }
    }

    free(visite);
}

void afficherGraphe(Graphe* graphe,int *rang) {
    for (int i = 1; i < graphe->nombreNoeuds; ++i) {
        Noeud* noeudCourant = graphe->listeAdjacence[i];
        printf("Noeud %d:", i);

        while (noeudCourant != NULL) {
            printf(" -> %d", noeudCourant->valeur);
            noeudCourant = noeudCourant->suivant;
        }
        printf("    /Rang %d",rang[i]);
        printf("\n");
    }
}

int main() {
    FILE *fichier = fopen("precedences.txt", "r");

    if (fichier == NULL) {
        fprintf(stderr, "Impossible d'ouvrir le fichier.\n");
        return 1;
    }

    int nombreTotalNoeuds = trouverNombreNoeuds(fichier);

    // Réinitialiser le curseur du fichier pour lire à partir du début
    fseek(fichier, 0, SEEK_SET);

    Graphe* graphe = initialiserGraphe(nombreTotalNoeuds);

    int source, destination;
    while (fscanf(fichier, "%d %d", &source, &destination) == 2) {
        ajouterArete(graphe, source, destination);
    }

    fclose(fichier);

    int* rang = (int*)malloc(nombreTotalNoeuds * sizeof(int));
    triTopologique(graphe, rang);

    // Afficher le rang de chaque opération
    afficherGraphe(graphe,rang);

    free(rang);
    libererGraphe(graphe);

    return 0;
}
